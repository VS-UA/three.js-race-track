<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Car Track Race</title>
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
		
	</style>
</head>
<body>
	<!--
	<div class="container">
		<div id="info" class="boxed">
			<div class="column">
				<p>
					"Use <kbd>WASD</kbd> to move the car."
				</p>
				<p>
					"Press <kbd>Space</kbd> to change the camera view."
				</p>
				<p>
					"Click <kbd>Mouse1</kbd> to turn on/off the car lights."
				</p>
			</div>
		</div>
	</div>
	-->
	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

	<script type = "importmap">
	{
		"imports": {
			"three": "https://threejs.org/build/three.module.js",
			"three/addons/": "https://threejs.org/examples/jsm/"
		}
	}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

		//To keep track of the keyboard and mouse
		// car controls variables for movement and camera view
		var keyD = false, keyA = false, keyS = false, keyW = false, space = false, car_view = false, driver_view = false,
		mouse1 = false, mouse2 = false, mouse_wheel = false;
		// car speed variables
		var carSpeed = 0, carMaxSpeed = 3, carMaxReverseSpeed = -1.5, carAcceleration = 0.01, carBreaking = 0.03, carTurnSpeed = 0.02, 
		carDecelerate = 0.01, carReverseAcceleration = 0.01;

		// Function to create a car
		function createCar(type, color = 0x0000ff) {
			// Wheels
			const cylinder = new THREE.CylinderGeometry(0.5, 0.5, 6, 32);
			const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
			const wheel1 = new THREE.Mesh(cylinder, wheelMaterial); // front wheels
			wheel1.rotation.z = Math.PI / 2;
			wheel1.position.set(0, 0.5, 8);
			const wheel2 = new THREE.Mesh(cylinder, wheelMaterial); // back wheels
			wheel2.rotation.z = Math.PI / 2;
			wheel2.position.set(0, 0.5, 0);
			
			// Body and Top
			// create a cube geometry for the car
			let carGeometry, windowGeometry, cabinGeometry;
			switch (type) {
				case "sport":
					carGeometry = new THREE.BoxGeometry(1.5, 0.8, 3);
					windowGeometry = new THREE.BoxGeometry(0.8, 0.8, 1.5);
					cabinGeometry = new THREE.BoxGeometry(1.5, 0.8, 1.5);
					break;
				case "f1":
					carGeometry = new THREE.BoxGeometry(1, 0.5, 2);
					windowGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
					cabinGeometry = new THREE.BoxGeometry(1, 0.5, 1);
					break;
				default:
					carGeometry = new THREE.BoxGeometry(5, 1, 10);
					windowGeometry = new THREE.BoxGeometry(3, 2, 6);
					cabinGeometry = new THREE.BoxGeometry(3, 2, 6);
			}

			// create a material for the car
			const carMaterial = new THREE.MeshStandardMaterial({ color: color });

			// create a mesh for the car
			const carMesh = new THREE.Mesh(carGeometry, carMaterial);
			carMesh.position.set(0, 1, 4);

			// windows of the car
			const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
			windowMaterial.opacity = 0.5;
			windowMaterial.transparent = true;
			const window = new THREE.Mesh(windowGeometry, windowMaterial);
			window.position.set(0, 1.5, 4);

			// cabin of the car
			/*const cabinMaterial = new THREE.MeshStandardMaterial({ color: 0xf0f0f0 });
			const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
			cabin.position.set(0, 1, 4);
*/

			let car = new THREE.Group();
			car.add(carMesh); // add the car mesh to the car group
			car.add(window); // add the top to the car group
			//car.add(cabin); // add the cabin to the car group
			car.add(wheel1); // add the front wheels to the car group
			car.add(wheel2); // add the back wheels to the car group
			return car; // return the car group
		}

		function createTrack() {
			const track = new THREE.Group();

			// Define the track geometry
			const capsuleGeometry = new THREE.CapsuleGeometry(350, 600, 32, 2);
			const capsuleMaterial = new THREE.MeshStandardMaterial({ color: 0x7f7f7f });
			const capsuleMesh = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
			capsuleMesh.rotation.z = -Math.PI / 2;
			capsuleMesh.position.y = 0.01;

			// eliminate center part of the capsule 
			const capsule = new THREE.CapsuleGeometry(250, 500, 32, 2);
			const capsuleMaterial2 = new THREE.MeshStandardMaterial({ color: 0x008000 });
			const capsuleMesh2 = new THREE.Mesh(capsule, capsuleMaterial2);
			capsuleMesh2.rotation.z = -Math.PI / 2;
			capsuleMesh2.position.y = 0.03;


			// outer limits of the track
			const outerLimits = new THREE.CapsuleGeometry(355, 605, 32, 2);
			const outerLimitsMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const outerLimitsMesh = new THREE.Mesh(outerLimits, outerLimitsMaterial);
			outerLimitsMesh.rotation.z = -Math.PI / 2;
			outerLimitsMesh.position.y = 0.001;

			// inner limits of the track
			const innerLimits = new THREE.CapsuleGeometry(255, 505, 32, 2);
			const innerLimitsMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const innerLimitsMesh = new THREE.Mesh(innerLimits, innerLimitsMaterial);
			innerLimitsMesh.rotation.z = -Math.PI / 2;
			innerLimitsMesh.position.y = 0.02;

			track.add(capsuleMesh);
			track.add(capsuleMesh2);
			track.add(outerLimitsMesh);
			track.add(innerLimitsMesh);
			return track;
		}

		// Function to create a lightposts
		function createLightPost(x, y, z, lightnum) {
			const lightPost = new THREE.Group();

			// the structure of the lightpost
			// create a cylinder geometry for the lightposts
			const cylinder = new THREE.CylinderGeometry(2, 2, 125, 32);
			const postMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
			const postMesh = new THREE.Mesh(cylinder, postMaterial);
			postMesh.position.set(x, y, z);

			let square, lightMaterial, lightMesh;
			// need special handling for curve lightposts
			if(lightnum == 2 || lightnum == 6){
				// create a square geometry for the lightposts
				square = new THREE.BoxGeometry(15, 15, 27);
				lightMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
				lightMesh = new THREE.Mesh(square, lightMaterial);
				lightMesh.position.set(x, y + 70, z);
				lightMesh.rotation.z = Math.PI / 4;
			} else{
				// create a square geometry for the lightposts
				square = new THREE.BoxGeometry(27, 15, 15);
				lightMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
				lightMesh = new THREE.Mesh(square, lightMaterial);
				lightMesh.position.set(x, y + 70, z);
				lightMesh.rotation.x = Math.PI / 4;
			}

			// the light
			const rectLight = new THREE.RectAreaLight(0xffffff, 300);
			rectLight.position.set( x, y + 70, z);
			rectLight.lookAt( x, y, z );
			rectLight.visible = true;
			//rectLight.castShadow = true;
			rectLight.name = "post_light" + lightnum;
			console.log(rectLight.name);
			
			lightPost.add( rectLight );			
			lightPost.add(postMesh);
			lightPost.add(lightMesh);
			return lightPost; // return the lightposts mesh
		}

		function fillScenery(scene) {
			// Create a trophy
			const trophyGroup = new THREE.Group();

			// Define materials to use for the trophy components
			const goldMaterial = new THREE.MeshPhongMaterial({
				color: 0xffd700, // gold color
				shininess: 100,
			});
			const blackMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000, // black color
			});
			const redMaterial = new THREE.MeshBasicMaterial({
				color: 0xff0000, // red color
			});

			// Create the trophy base
			const baseGeometry = new THREE.CylinderGeometry(20, 30, 10, 32);
			const baseMesh = new THREE.Mesh(baseGeometry, blackMaterial);
			trophyGroup.add(baseMesh);

			// Create the trophy stem
			const stemGeometry = new THREE.CylinderGeometry(10, 10, 35, 32);
			const stemMesh = new THREE.Mesh(stemGeometry, goldMaterial);
			stemMesh.position.set(0, 20, 0);
			trophyGroup.add(stemMesh);

			// Create the trophy cup
			const cupGeometry = new THREE.CylinderGeometry(25, 30, 20, 32);
			const cupMesh = new THREE.Mesh(cupGeometry, goldMaterial);
			cupMesh.position.set(0, 50, 0);
			trophyGroup.add(cupMesh);

			// Create the trophy cup handles
			const handleGeometry = new THREE.TorusGeometry(8, 2);
			const handleMesh1 = new THREE.Mesh(handleGeometry, blackMaterial);
			handleMesh1.position.set(25, 50, 0);
			handleMesh1.rotation.z = Math.PI / 2;
			trophyGroup.add(handleMesh1);

			const handleMesh2 = new THREE.Mesh(handleGeometry, blackMaterial);
			handleMesh2.position.set(-25, 50, 0);
			handleMesh2.rotation.z = Math.PI / 2;
			trophyGroup.add(handleMesh2);

			// Set the position of the trophy group
			trophyGroup.position.set(0, 0, 0);
			trophyGroup.name = "trophy";
			scene.add(trophyGroup);

			// Create a racing flag
			const racingFlag = new THREE.Group();
			const flagPole = new THREE.CylinderGeometry(0.05, 0.05, 3, 32);
			const flagPoleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
			const flagPoleMesh = new THREE.Mesh(flagPole, flagPoleMaterial);
			racingFlag.add(flagPoleMesh);

			const flag = new THREE.PlaneGeometry(1, 1);
			const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
			const flagMesh = new THREE.Mesh(flag, flagMaterial);
			flagMesh.rotation.z = Math.PI / 2;
			flagMesh.position.set(0.5, 1, 0);
			racingFlag.add(flagMesh);

			racingFlag.position.set(0, 35, -300);
			racingFlag.scale.set(10, 10, 10);
			racingFlag.name = "flag";
			scene.add(racingFlag);

			// Create a wind measurer
			const windMeasure = new THREE.Group();
			const arrow = new THREE.Group();

			const windArrowGeometry = new THREE.ConeGeometry(5, 16, 16);
			const windArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x770000 });
			const windArrow = new THREE.Mesh(windArrowGeometry, windArrowMaterial);
			windArrow.rotation.x = Math.PI / 2;
			windArrow.position.set(0, 0, 20);
			arrow.add(windArrow);

			const windSpin = new THREE.CylinderGeometry(1, 1, 25, 32);
			const windSpinMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windSpinMesh = new THREE.Mesh(windSpin, windSpinMaterial);
			windSpinMesh.rotation.x = Math.PI / 2;
			windSpinMesh.position.set(0, 0, -12.5);
			windSpinMesh.geometry.translate(0, 12.5, 0);
			
			arrow.position.set(0, 55, 40);
			arrow.name = "arrow";
			arrow.add(windSpinMesh);

			const windMeasurerPole = new THREE.CylinderGeometry(3, 3, 100, 32);
			const windMeasurerPoleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windMeasurerPoleMesh = new THREE.Mesh(windMeasurerPole, windMeasurerPoleMaterial);
			windMeasurerPoleMesh.position.set(0, 0, 40);
			windMeasure.add(windMeasurerPoleMesh);

			const windMeasurerBase = new THREE.CylinderGeometry(1, 1, 20, 32);
			const windMeasurerBaseMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windMeasurerBaseMesh = new THREE.Mesh(windMeasurerBase, windMeasurerBaseMaterial);
			windMeasurerBaseMesh.position.set(0, 50, 40);
			windMeasure.add(windMeasurerBaseMesh);

			windMeasure.add(arrow);

			windMeasure.position.set(0, 5, -250);
			windMeasure.name = "windMeasure";
			scene.add(windMeasure);

			// Create a wind turbine
			const windTurbine = new THREE.Group();
			const towerGeometry = new THREE.CylinderGeometry(10, 10, 100, 8);
			const towerMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
			const towerMesh = new THREE.Mesh(towerGeometry, towerMaterial);
			towerMesh.position.set(0, 50, 0);
			windTurbine.add(towerMesh);

			// Blades
			const blades = new THREE.Group();
			const bladeGeometry = new THREE.BoxGeometry(400, 5, 40);
			const bladeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const blade1Mesh = new THREE.Mesh(bladeGeometry, bladeMaterial);
			blade1Mesh.position.set(0, 120, 0);
			blade1Mesh.scale.set(0.5, 0.5, 0.5);
			blade1Mesh.rotation.x = Math.PI / 2;
			blade1Mesh.rotation.y = Math.PI / 4;
			blades.add(blade1Mesh);

			const blade2Mesh = new THREE.Mesh(bladeGeometry, bladeMaterial);
			blade2Mesh.position.set(0, 120, 0);
			blade2Mesh.scale.set(0.5, 0.5, 0.5);
			blade2Mesh.rotation.x = Math.PI / 2;
			blade2Mesh.rotation.y = Math.PI / 4 + (2 * Math.PI) / 3;
			blades.add(blade2Mesh);

			const blade3Mesh = new THREE.Mesh(bladeGeometry, bladeMaterial);
			blade3Mesh.position.set(0, 120, 0);
			blade3Mesh.scale.set(0.5, 0.5, 0.5);
			blade3Mesh.rotation.x = Math.PI / 2;
			blade3Mesh.rotation.y = Math.PI / 4 + (4 * Math.PI) / 3;
			blades.add(blade3Mesh);
			blades.name = "blades";

			windTurbine.add(blades);

			windTurbine.position.set(-150, 0, 450);
			windTurbine.name = "windTurbine";
			scene.add(windTurbine);
		}
		/*
		// Update render image size and camera aspect when the window is resized
		function resizeWindow(eventParam) {
			const width = window.innerWidth;
			const height = window.innerHeight;

			scene.camera.aspect = width / height;
			scene.camera.updateProjectionMatrix();

			scene.renderer.setSize(width, height);
		}
		*/
		document.addEventListener('keydown', onDocumentKeyDown, false);
		document.addEventListener('keyup', onDocumentKeyUp, false);
		document.addEventListener('mousedown', onDocumentMouseDown, false);
		document.addEventListener('mouseup', onDocumentMouseUp, false);

		function onDocumentKeyDown(event) {
			switch (event.keyCode) {
				case 32: //space
					space = true;
					break;
				case 68: //d
					keyD = true;
					break;
				case 83: //s
					keyS = true;
					break;
				case 65: //a
					keyA = true;
					break;
				case 87: //w
					keyW = true;
					break;
			}
		}
		
		function onDocumentKeyUp(event) {
			switch (event.keyCode) {
				case 32: //space
					space = false;
					break;
				case 68: //d
					keyD = false;
					break;
				case 83: //s
					keyS = false;
					break;
				case 65: //a
					keyA = false;
					break;
				case 87: //w
					keyW = false;
					break;
			}
		}

		function onDocumentMouseDown(event) {
			switch (event.button) {
				case 0: //mouse1
					mouse1 = true;
					break;
				case 1: //mouse_wheel
					mouse_wheel = true;
					break;
				case 2: //mouse2
					mouse2 = true;
					break;
			}
		}

		function onDocumentMouseUp(event) {
			switch (event.button) {
				case 0: //mouse1
					mouse1 = false;
					break;
				case 1: //mouse_wheel
					mouse_wheel = false;
					break;
				case 2: //mouse2
					mouse2 = false;
					break;
			}
		}

		function init() {
			// initialize scene and plane
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x00001f);
			
			// ground
			const plane = new THREE.PlaneGeometry(20000, 20000, 32);
			const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x008000 });
			const planeMesh = new THREE.Mesh(plane, planeMaterial);
			planeMesh.rotation.x = -Math.PI / 2;
			planeMesh.position.set(0, -0.1, 0);
			scene.add(planeMesh);

			// track
			let track = createTrack();
			scene.add(track);

			// lightposts
			for(var i = 0; i < 8; i++){
				const angle = Math.PI * 2 / 8 * i;
				var x = Math.sin(angle) * (350 + 200);
				var z = Math.cos(angle) * (350 + 200);
				if(i == 0){
					z -= 150;
				} else if(i == 2){
					x += 150;
				} 
				else if(i == 4){
					z += 150;
				} else if(i == 6){
					x -= 150;
				}
				let lightpost = createLightPost(x, 5, z, i);
				scene.add(lightpost);
			}

			// create a mesh for the car
			let car = createCar();
			car.position.set(1,1,1);
			// headlights of the car
			const left_light = new THREE.SpotLight(0xffffff, 1.0, 35.0, Math.PI/6, 0.5, 0.3);
			left_light.position.set(car.position.x - 2.5, car.position.y, car.position.z);
			console.log(car.position);
			left_light.target.position.set(0, 0, 100);
			left_light.castShadow = true;
			left_light.shadow.mapSize.width = 1024;
			left_light.shadow.mapSize.height = 1024;
			left_light.visible = true;
			left_light.name = "left_light";

			const right_light = new THREE.SpotLight(0xffffff, 1.0, 35.0, Math.PI/6, 0.5, 0.3);
			right_light.position.set(car.position.x + 2.5, car.position.y, car.position.z);
			right_light.target.position.set(0,0,100);
			right_light.castShadow = true;
			right_light.shadow.mapSize.width = 1024;
			right_light.shadow.mapSize.height = 1024;
			right_light.visible = true;
			right_light.name = "right_light";

			car.add(left_light);
			car.add(right_light);
			scene.add(car);

			fillScenery(scene);

			// THE LIGHTS
			// ambient light
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
			scene.add(ambientLight);

			// THE CAMERAS
			// Orthographic camera for top view
			const camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000);
			camera.position.set(0, 100, 0);
			camera.lookAt(0, 0, 0);

			// Perspective camera for inside and outside car view
			const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera1.position.set(0, 10, 20);
			camera1.lookAt(0, 0, 0);

			// driver view
			const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera2.position.set(car.position.x, car.position.y + 2, car.position.z + 5);
			camera2.lookAt(car.position.x, car.position.y, car.position.z);

			var activeCamera = camera;
			scene.add(activeCamera);

			// THE RENDERER
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(new THREE.Color(0xaaaaaa));
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;

			// Add the output of the renderer
			document.body.appendChild(renderer.domElement);

			// Render the scene
			renderer.render(scene, activeCamera);

			//window.addEventListener('resize', resizeWindow);

			animate();
			var step = 0;
			// animate the scene
			function animate() {
				var post_lights = [];
				for(var x = 0; x < 8; x++){
						post_lights[x] = scene.getObjectByName('post_light' + x);
				}
				let left_light = scene.getObjectByName('left_light');
				let right_light = scene.getObjectByName('right_light');
				const trophy = scene.getObjectByName('trophy');
				const arrow = scene.getObjectByName('arrow');
				const flag = scene.getObjectByName('flag');
				const blades = scene.getObjectByName("windTurbine").getObjectByName("blades");


				// rotate the trophy
				trophy.rotation.y += 0.01;

				// rotate the arrow
				arrow.rotation.y = Math.cos(step);

				// rotate the flag
				flag.rotation.x = step * Math.sin(step);
				flag.rotation.y = step * Math.cos(step);
				flag.rotation.z = step * Math.sin(step);

				// rotate the blades
				blades.rotation.z = Math.sin(step);

				step += 0.01;

				if(step >= 30){
					step = 0.01;
				}

				// Move the car forward or backward
				if (keyW) {
					if(carSpeed < 0){
						carSpeed += carBreaking;
					} else{
						carSpeed += carAcceleration;
					}
					if (carSpeed > carMaxSpeed) {
						carSpeed = carMaxSpeed;
					}
					carAcceleration += 0.0001;
				} else if (keyS) {
					if(carSpeed > 0){
						carSpeed -= carBreaking;
					} else{
						carSpeed -= carReverseAcceleration;
					}
					if (carSpeed < carMaxReverseSpeed) {
						carSpeed = carMaxReverseSpeed;
					}
					carReverseAcceleration += 0.0001;
				}

				// Turn the car
				if(keyA){
					if(carSpeed > 0){
						car.rotation.y += carTurnSpeed;
					} else if(carSpeed < 0){
						car.rotation.y -= carTurnSpeed;
					}
				}
				if(keyD){
					if(carSpeed > 0){
						car.rotation.y -= carTurnSpeed;
					} else if(carSpeed < 0){
						car.rotation.y += carTurnSpeed;
					}
				}

				// Decelerate the car if no key is pressed
				if(!keyW && !keyS){
					if(carSpeed > 0){
						carSpeed -= carDecelerate;
					}
					else if(carSpeed < 0){
						carSpeed += carDecelerate;
					}
					// Reset acceleration and reverse acceleration
					if(carAcceleration > 0.01){
						carAcceleration -= 0.0001;
					}
					if(carReverseAcceleration > 0.01){
						carReverseAcceleration -= 0.0001;
					}
					// Stop the car if it's speed is too low (to prevent it from moving forever)
					if(carSpeed < 0.01 && carSpeed > -0.01){
						carSpeed = 0;
					}
				}

				// Make the car move base on it's speed and rotation
				car.position.x -= carSpeed * Math.sin(car.rotation.y);
				car.position.z -= carSpeed * Math.cos(car.rotation.y);

				if(space){
					if(!car_view){
						if(!driver_view){
							activeCamera = camera1;
							driver_view = true;
						}
						else{
							activeCamera = camera2;
							driver_view = false;
							car_view = true;
						}
					}
					else{
						activeCamera = camera;
						car_view = false;
					}
					space = false;
				}

				if(activeCamera === camera1){
					activeCamera.position.copy(car.position);
					if(carSpeed >= 0){
						activeCamera.position.add(new THREE.Vector3(0, 5, 8).applyQuaternion(car.quaternion));
					} else if(carSpeed < 0){
						activeCamera.position.add(new THREE.Vector3(0, 5, -8).applyQuaternion(car.quaternion));
					}
					activeCamera.lookAt(car.position);
				} else if(activeCamera === camera2){
					activeCamera.position.copy(car.position);
					if(carSpeed >= 0){
						activeCamera.position.add(new THREE.Vector3(0, 2, 8).applyQuaternion(car.quaternion));
					} else if(carSpeed < 0){
						activeCamera.position.add(new THREE.Vector3(0, 2, -4).applyQuaternion(car.quaternion));
					}
					activeCamera.lookAt(car.position);
				}

				if(mouse1){
					left_light.visible = !left_light.visible;
					right_light.visible = !right_light.visible;
					mouse1 = false;
				}
				if(mouse2){
					for(var x = 0; x < 8; x++){
						post_lights[x].visible = !post_lights[x].visible;
					}
					mouse2 = false;
				}
				//left_light.applyQuaternion(car.quaternion);
				//right_light.applyQuaternion(car.quaternion);

				//window.addEventListener('resize', resizeWindow);
				
				requestAnimationFrame(animate);
				renderer.render(scene, activeCamera);
			}
		}

		window.onload = init;
	</script>
</body>
</html>
