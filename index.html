<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Car Track Race</title>
	<style>
		body {
			margin: 0px;
			overflow: hidden;
		}
		
	</style>
</head>
<body>

	<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

	<script type = "importmap">
	{
		"imports": {
			"three": "https://threejs.org/build/three.module.js",
			"three/addons/": "https://threejs.org/examples/jsm/"
		}
	}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import Stats from 'three/addons/libs/stats.module.js';
		import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { Reflector } from 'three/addons/objects/Reflector.js';

		//To keep track of the keyboard and mouse
		// car controls variables for movement and camera view
		var keyD = false, keyA = false, keyS = false, keyW = false, space = false, car_view = false, driver_view = false,
		mouse1 = false, mouse2 = false, mouse_wheel = false, sound_fx = true;
		// car speed variables
		var carSpeed = 0, carMaxSpeed = 3, carMaxReverseSpeed = -1.5, carAcceleration = 0.01, carBreaking = 0.03, carTurnSpeed = 0.02, 
		carDecelerate = 0.01, carReverseAcceleration = 0.01;

		let power_up, ambientLight, songIndex = 0;

		// car material
		let carMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });

		// Define the variables for the wander behavior for the camel
		let camelWanderTarget = new THREE.Vector3(); // The target position for wandering
		const camelWanderRadius = 50; // Radius of the wander circle
		const camelWanderDistance = 10000; // Distance of the wander circle from the camel
		const camelWanderMaxForce = 0.05; // Maximum steering force for wander behavior

		// Define the variables for the wander behavior for the tumbleweeds
		let tumbleweedWanderTarget = new THREE.Vector3(); // The target position for wandering
		const tumbleweedWanderRadius = 50; // Radius of the wander circle
		const tumbleweedWanderDistance = 300; // Distance of the wander circle from the tumbleweed
		const tumbleweedWanderMaxForce = 0.5; // Maximum steering force for wander behavior

		// create an AudioListener and add it to the camera
		const listener = new THREE.AudioListener();

		// create a global audio source
		const backgroundSound = new THREE.Audio( listener );

		// create a global audio source
		const engineSound = new THREE.Audio( listener );

		// create a positional audio source
		const powerUpSound = new THREE.PositionalAudio( listener );

		// create a global audio source
		const song = new THREE.Audio( listener );

		// load a sound and set it as the Audio object's buffer
		const audioLoader = new THREE.AudioLoader();
		audioLoader.load( './sounds/GCN Dry Dry Desert - Mario Kart 8 Deluxe OST.mp3', function( buffer ) {
			backgroundSound.setBuffer( buffer );
			backgroundSound.setLoop( true );
			backgroundSound.setVolume( 0.15 ); // 0.15
			backgroundSound.play();
		});
		
		// engine sound effect
		audioLoader.load( './sounds/car_sound.wav', function( buffer ) {
			engineSound.setBuffer( buffer );
			engineSound.setLoop( true );
			engineSound.setVolume( 0.20 ); // 0.2
		});

		// power up sound effect
		audioLoader.load("./sounds/Mario Kart - Star.mp3", function (buffer) {
			powerUpSound.setBuffer(buffer);
			powerUpSound.setRefDistance(5);
		});

		function gui(scene) {
			var post_lights = [];
			for(var x = 0; x < 8; x++){
				post_lights[x] = scene.getObjectByName('post_light' + x);
			}
			const gui = new GUI();

			// Display information about the controls
			const instructions = gui.addFolder('Controls');
			instructions.add({ W: 'Move forward' }, 'W').name('W').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ S: 'Break/Move backward' }, 'S').name('S').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ A: 'Turn left' }, 'A').name('A').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ D: 'Turn right' }, 'D').name('D').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ Space: 'Change perspective' }, 'Space').name('Space').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ Mouse: 'Lights On/Off' }, 'Mouse').name('Mouse').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;
			instructions.add({ PowerUp: 'Pick it up for extra speed!' }, 'PowerUp').name('PowerUp').listen(false).domElement.getElementsByTagName('input')[0].disabled = true;

			// Control the sky color and lights on/off
			const time = gui.addFolder('Lighting');

			// Create an object to store the color value
			const colors = {
				Night: 0x00001f,
				Day: 0x6cd4ff,
				Afternoon: 0xffd089
			};

			const selectedColor = {
				color: Object.keys(colors)[0]
			};

			const colorController = time.add(selectedColor, 'color', Object.keys(colors)).name('Sky Color');

			// Change the color background based on the indice selected
			colorController.onChange(function (selectedKey) {
				scene.background = new THREE.Color(colors[selectedKey]);
			});
			

			// Create an object to store your checkbox value
			const options = {
				Lights: true,
			};

			// Add a checkbox control to the GUI
			time.add(options, 'Lights').onChange(function (value) {
				// Callback function executed when the checkbox value changes
				if (value) {
					// Checkbox is checked
					for(var x = 0; x < 8; x++){
						post_lights[x].visible = !post_lights[x].visible;
					}
				} else {
					// Checkbox is unchecked
					for(var x = 0; x < 8; x++){
						post_lights[x].visible = !post_lights[x].visible;
					}
				}
			});

			time.add({ intensity: 0.1 }, 'intensity', 0, 1)
				.step(0.05)
				.name('Ambient light intensity')
				.onChange((value) => {
					ambientLight.intensity = value;
				});

			time.add({ post_intensity: 300 }, 'post_intensity', 0, 1000)
				.step(10)
				.name('Lights intensity')
				.onChange((value) => {
					for(var x = 0; x < 8; x++){
						post_lights[x].intensity = value;
					}
				});

			time.close();

			// Audio controls
			const audio = gui.addFolder('Audio');

			const music = {
				Audio: true,
				Radio : false
			}

			// Add a checkbox control to the GUI
			audio.add(music, 'Audio').onChange(function (value) {
				// Callback function executed when the checkbox value changes
				if (value) {
					backgroundSound.play();
					engineSound.play();
					sound_fx = true;
				} else {
					backgroundSound.stop();
					engineSound.stop();
					sound_fx = false;
				}
			});

			// Add a checkbox control to the GUI
			audio.add(music, 'Radio').onChange(function (value) {
				// Callback function executed when the checkbox value changes
				if (value) {
					nextSong();
				} else {
					song.stop();
				}
			});

			const controlSong = {
				nextSong: function() {
					if (music.Radio) {
						nextSong();
					}
				},
				volume: 0.2
			};

			audio.add(controlSong, 'nextSong').name('Next song');
			audio.add(controlSong, 'volume', 0, 1).name('Volume').onChange(function(value) {
  				song.setVolume(value);
			});

			audio.close();	
		}

		// Function to get the next song
		function nextSong() {
			const songsFolder = './sounds/songs/';
			const songs = [
				'song1.mp3',
				'song2.mp3',
				'song3.mp3',
				'song4.mp3',
				'song5.mp3',
				'song6.mp3',
				'song7.mp3',
				'song8.mp3',
				'song9.mp3'
			];

			const songFilePath = songsFolder + songs[songIndex];

			audioLoader.load(songFilePath, function(buffer) {
				song.stop(); // Stop the currently playing song
				song.setBuffer(buffer);
				song.setLoop(true);
				song.setVolume(0.2);
				song.play();
				song.onEnded = () => {
					nextSong();
				}
			});

			songIndex += 1;
			if (songIndex >= songs.length) {
				songIndex = 0;
			}
		}

		// Function to create a car
		function createCar(type, color = 0x0000ff) {
			// Wheels
			const cylinder = new THREE.CylinderGeometry(0.5, 0.5, 6, 32);
			const wheelMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
			const wheel1 = new THREE.Mesh(cylinder, wheelMaterial); // front wheels
			wheel1.rotation.z = Math.PI / 2;
			wheel1.position.set(0, 0.5, 8);
			const wheel2 = new THREE.Mesh(cylinder, wheelMaterial); // back wheels
			wheel2.rotation.z = Math.PI / 2;
			wheel2.position.set(0, 0.5, 0);
			
			// Body and Top
			// create a mesh for the car
			const carGeometry = new THREE.BoxGeometry(5, 1, 10);
			const carMesh = new THREE.Mesh(carGeometry, carMaterial);
			carMesh.position.set(0, 1, 4);

			// windows of the car
			const windowGeometry = new THREE.BoxGeometry(3, 2, 6);
			const windowMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
			windowMaterial.opacity = 0.2;
			windowMaterial.transparent = true;
			const window = new THREE.Mesh(windowGeometry, windowMaterial);
			window.position.set(0, 1.5, 4);

			// side mirrors
			const mirrorGeometry = new THREE.BoxGeometry(1, 0.6, 0.1);
			const mirrorMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff });
			const leftMirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
			leftMirror.position.set(-2.9, 1.75, 1);
			leftMirror.rotation.set(-Math.PI / 20, 0, 0);
			const rightMirror = new THREE.Mesh(mirrorGeometry, mirrorMaterial);
			rightMirror.position.set(2.9, 1.75, 1);
			rightMirror.rotation.set(-Math.PI / 20, 0, 0);

			// Add mirror effect using Reflector.js
			const mirrorOptions = {
				color: 0xb5b5b5,
				textureWidth: window.innerWidth * window.devicePixelRatio,
				textureHeight: window.innerHeight * window.devicePixelRatio,
			};
			
			const leftMirrorReflector = new Reflector(mirrorGeometry, mirrorOptions);
			leftMirrorReflector.position.copy(leftMirror.position);
			leftMirrorReflector.rotation.copy(leftMirror.rotation);
			const rightMirrorReflector = new Reflector(mirrorGeometry, mirrorOptions);
			rightMirrorReflector.position.copy(rightMirror.position);
			rightMirrorReflector.rotation.copy(rightMirror.rotation);

			// Group the mirror meshes and reflectors
			const mirrorsGroup = new THREE.Group();
			mirrorsGroup.add(leftMirror, rightMirror, leftMirrorReflector, rightMirrorReflector);	

			// car headlights static figure representation
			const headLightGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.1);
			const headLightMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
			const leftheadLight = new THREE.Mesh(headLightGeometry, headLightMaterial);
			leftheadLight.position.set(-2, 1, -1);
			const rightheadLight = new THREE.Mesh(headLightGeometry, headLightMaterial);
			rightheadLight.position.set(2, 1, -1);

			// car blinkers
			const blinkerGeometry = new THREE.BoxGeometry(0.2, 0.3, 0.1);
			const blinkerMaterial = new THREE.MeshPhongMaterial({ color: 0xff9000 });
			const leftBlinker = new THREE.Mesh(blinkerGeometry, blinkerMaterial);
			leftBlinker.position.set(-2.4, 1, -1);
			const rightBlinker = new THREE.Mesh(blinkerGeometry, blinkerMaterial);
			rightBlinker.position.set(2.4, 1, -1);
						
			let car = new THREE.Group();
			car.add(carMesh); // add the car mesh to the car group
			car.add(window); // add the top to the car group
			car.add(wheel1); // add the front wheels to the car group
			car.add(wheel2); // add the back wheels to the car group
			car.add(mirrorsGroup); // add the mirrors to the car group (including reflectors)
			car.add(leftheadLight); // add the left blinker to the car group
			car.add(rightheadLight); // add the right blinker to the car group
			car.add(leftBlinker); // add the left blinker to the car group
			car.add(rightBlinker); // add the right blinker to the car group
			return car; // return the car group
		}

		function createTrack() {
			const track = new THREE.Group();

			// Define the track geometry
			const capsuleGeometry = new THREE.CapsuleGeometry(350, 600, 32, 2);
			const capsuleMaterial = new THREE.MeshStandardMaterial({ color: 0x7f7f7f });
			const capsuleMesh = new THREE.Mesh(capsuleGeometry, capsuleMaterial);
			capsuleMesh.rotation.z = -Math.PI / 2;
			capsuleMesh.position.y = 0.01;

			// eliminate center part of the capsule 
			const capsule = new THREE.CapsuleGeometry(250, 500, 32, 2);
			const capsuleMaterial2 = new THREE.MeshStandardMaterial({ color: 0x008000 });
			const capsuleMesh2 = new THREE.Mesh(capsule, capsuleMaterial2);
			capsuleMesh2.rotation.z = -Math.PI / 2;
			capsuleMesh2.position.y = 0.03;


			// outer limits of the track
			const outerLimits = new THREE.CapsuleGeometry(355, 605, 32, 2);
			const outerLimitsMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const outerLimitsMesh = new THREE.Mesh(outerLimits, outerLimitsMaterial);
			outerLimitsMesh.rotation.z = -Math.PI / 2;
			outerLimitsMesh.position.y = 0.001;

			// inner limits of the track
			const innerLimits = new THREE.CapsuleGeometry(255, 505, 32, 2);
			const innerLimitsMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const innerLimitsMesh = new THREE.Mesh(innerLimits, innerLimitsMaterial);
			innerLimitsMesh.rotation.z = -Math.PI / 2;
			innerLimitsMesh.position.y = 0.02;

			// Create a starting line
			const numSquares = 10; // Number of squares in the starting line
			const squareSize = 9.5; // Size of each square
			const lineOffset = ((numSquares * squareSize) / 2 - squareSize / 2) + 2.5; // Offset to center the line

			for (let i = 0; i < numSquares; i++) {
				const squareGeometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
				const squareMaterial = new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0xffffff : 0x000000 });
				const square = new THREE.Mesh(squareGeometry, squareMaterial);
				square.position.set(0, -4.45, -300 + (i * squareSize - lineOffset));
				track.add(square);
			}

			for (let i = 0; i < numSquares; i++) {
				const squareGeometry = new THREE.BoxGeometry(squareSize, squareSize, squareSize);
				const squareMaterial = new THREE.MeshBasicMaterial({ color: i % 2 === 0 ? 0x000000 : 0xffffff });
				const square = new THREE.Mesh(squareGeometry, squareMaterial);
				square.position.set(9.5, -4.45, -300 + (i * squareSize - lineOffset));
				track.add(square);
			}

			track.add(capsuleMesh);
			track.add(capsuleMesh2);
			track.add(outerLimitsMesh);
			track.add(innerLimitsMesh);
			return track;
		}

		// Function to create a lightposts
		function createLightPost(x, y, z, lightnum) {
			const lightPost = new THREE.Group();

			// the structure of the lightpost
			// create a cylinder geometry for the lightposts
			const cylinder = new THREE.CylinderGeometry(2, 2, 125, 32);
			const postMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
			const postMesh = new THREE.Mesh(cylinder, postMaterial);
			postMesh.position.set(x, y, z);

			let square, lightMaterial, lightMesh;
			// need special handling for curve lightposts
			if(lightnum == 2 || lightnum == 6){
				// create a square geometry for the lightposts
				square = new THREE.BoxGeometry(15, 15, 27);
				lightMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
				lightMesh = new THREE.Mesh(square, lightMaterial);
				lightMesh.position.set(x, y + 70, z);
				lightMesh.rotation.z = Math.PI / 4;
			} else{
				// create a square geometry for the lightposts
				square = new THREE.BoxGeometry(27, 15, 15);
				lightMaterial = new THREE.MeshLambertMaterial({ color: 0xffff00 });
				lightMesh = new THREE.Mesh(square, lightMaterial);
				lightMesh.position.set(x, y + 70, z);
				lightMesh.rotation.x = Math.PI / 4;
			}

			// the light
			const rectLight = new THREE.RectAreaLight(0xffffff, 300);
			rectLight.position.set( x, y + 70, z);
			rectLight.lookAt( x, y, z );
			rectLight.visible = true;
			rectLight.name = "post_light" + lightnum;
			
			lightPost.add( rectLight );			
			lightPost.add(postMesh);
			lightPost.add(lightMesh);
			return lightPost; // return the lightposts mesh
		}

		function fillScenery(scene) {
			// Create a trophy
			const trophyGroup = new THREE.Group();

			// Define materials to use for the trophy components
			const goldMaterial = new THREE.MeshPhongMaterial({
				color: 0xffd700, // gold color
				shininess: 100,
			});
			const blackMaterial = new THREE.MeshBasicMaterial({
				color: 0x000000, // black color
			});
			const redMaterial = new THREE.MeshBasicMaterial({
				color: 0xff0000, // red color
			});

			// Create the trophy base
			const baseGeometry = new THREE.CylinderGeometry(20, 30, 10, 32);
			const baseMesh = new THREE.Mesh(baseGeometry, blackMaterial);
			trophyGroup.add(baseMesh);

			// Create the trophy stem
			const stemGeometry = new THREE.CylinderGeometry(10, 10, 35, 32);
			const stemMesh = new THREE.Mesh(stemGeometry, goldMaterial);
			stemMesh.position.set(0, 20, 0);
			trophyGroup.add(stemMesh);

			// Create the trophy cup
			const cupGeometry = new THREE.CylinderGeometry(25, 30, 20, 32);
			const cupMesh = new THREE.Mesh(cupGeometry, goldMaterial);
			cupMesh.position.set(0, 50, 0);
			trophyGroup.add(cupMesh);

			// Create the trophy cup handles
			const handleGeometry = new THREE.TorusGeometry(8, 2);
			const handleMesh1 = new THREE.Mesh(handleGeometry, blackMaterial);
			handleMesh1.position.set(25, 50, 0);
			handleMesh1.rotation.z = Math.PI / 2;
			trophyGroup.add(handleMesh1);

			const handleMesh2 = new THREE.Mesh(handleGeometry, blackMaterial);
			handleMesh2.position.set(-25, 50, 0);
			handleMesh2.rotation.z = Math.PI / 2;
			trophyGroup.add(handleMesh2);

			// Set the position of the trophy group
			trophyGroup.position.set(0, 0, 0);
			trophyGroup.name = "trophy";
			scene.add(trophyGroup);

			// Create a racing flag
			const racingFlag = new THREE.Group();
			const flagPole = new THREE.CylinderGeometry(0.05, 0.05, 3, 32);
			const flagPoleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
			const flagPoleMesh = new THREE.Mesh(flagPole, flagPoleMaterial);
			racingFlag.add(flagPoleMesh);

			const flag = new THREE.PlaneGeometry(1, 1);
			const flagMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
			const flagMesh = new THREE.Mesh(flag, flagMaterial);
			flagMesh.rotation.z = Math.PI / 2;
			flagMesh.position.set(0.5, 1, 0);
			racingFlag.add(flagMesh);

			racingFlag.position.set(0, 35, -300);
			racingFlag.scale.set(10, 10, 10);
			racingFlag.name = "flag";
			scene.add(racingFlag);

			// Create a wind measurer
			const windMeasure = new THREE.Group();
			const arrow = new THREE.Group();

			const windArrowGeometry = new THREE.ConeGeometry(5, 16, 16);
			const windArrowMaterial = new THREE.MeshBasicMaterial({ color: 0x770000 });
			const windArrow = new THREE.Mesh(windArrowGeometry, windArrowMaterial);
			windArrow.rotation.x = Math.PI / 2;
			windArrow.position.set(0, 0, 20);
			arrow.add(windArrow);

			const windSpin = new THREE.CylinderGeometry(1, 1, 25, 32);
			const windSpinMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windSpinMesh = new THREE.Mesh(windSpin, windSpinMaterial);
			windSpinMesh.rotation.x = Math.PI / 2;
			windSpinMesh.position.set(0, 0, -12.5);
			windSpinMesh.geometry.translate(0, 12.5, 0);
			
			arrow.position.set(0, 55, 40);
			arrow.name = "arrow";
			arrow.add(windSpinMesh);

			const windMeasurerPole = new THREE.CylinderGeometry(3, 3, 100, 32);
			const windMeasurerPoleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windMeasurerPoleMesh = new THREE.Mesh(windMeasurerPole, windMeasurerPoleMaterial);
			windMeasurerPoleMesh.position.set(0, 0, 40);
			windMeasure.add(windMeasurerPoleMesh);

			const windMeasurerBase = new THREE.CylinderGeometry(1, 1, 20, 32);
			const windMeasurerBaseMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			const windMeasurerBaseMesh = new THREE.Mesh(windMeasurerBase, windMeasurerBaseMaterial);
			windMeasurerBaseMesh.position.set(0, 50, 40);
			windMeasure.add(windMeasurerBaseMesh);

			windMeasure.add(arrow);

			windMeasure.position.set(0, 5, -250);
			windMeasure.name = "windMeasure";
			scene.add(windMeasure);

		}

		function usePowerUp() {
			if(sound_fx && !powerUpSound.isPlaying){
				backgroundSound.pause();
				engineSound.pause();
				powerUpSound.play();
			}

			if (carMaterial) {
				// Double the car variables
				carMaxSpeed *= 2;
				carTurnSpeed *= 1.01;
				carMaxReverseSpeed *= 2;
				carBreaking *= 2;

				// Assuming you have a variable for the car object
				const originalMaterial = carMaterial.clone();
				const originalColor = originalMaterial.color.clone();

				// Create a timer to switch the car's color rapidly
				const colorSwitchInterval = setInterval(() => {
					// Generate a random color for the car
					const randomColor = new THREE.Color(Math.random(), Math.random(), Math.random());

					// Apply the random color to the car's material
					carMaterial.color.copy(randomColor);
				}, 100); // Adjust the interval duration (in milliseconds) to control the color switching speed

				// Set a timer to revert the car's color and variables to the initial values after 5 seconds
				setTimeout(() => {
					clearInterval(colorSwitchInterval); // Clear the color switching interval
					// Restore the original material and color
					carMaterial.copy(originalMaterial);
      				carMaterial.color.copy(originalColor);

					// Restore the initial values of the car variables
					carSpeed = 0, carMaxSpeed = 3, carMaxReverseSpeed = -1.5, carAcceleration = 0.01, carBreaking = 0.03, carTurnSpeed = 0.02, 
					carDecelerate = 0.01, carReverseAcceleration = 0.01;

					if(sound_fx){
						backgroundSound.play();
						engineSound.play();
					}
				}, 5000); // Adjust the duration (in milliseconds) as needed
			}
		}

		function wander(camel) {
			const displacement = new THREE.Vector3();
			displacement.set(Math.random() * 2 - 1, 0, Math.random() * 2 - 1);
			displacement.normalize();
			displacement.multiplyScalar(camelWanderRadius);

			const wanderForce = new THREE.Vector3();
			wanderForce.addVectors(camelWanderTarget, displacement);
			wanderForce.sub(camel.position);
			wanderForce.normalize();
			wanderForce.multiplyScalar(camelWanderMaxForce);

			camel.position.add(wanderForce);

			// Update the wander target position periodically to create a wandering effect
			if (Math.random() < 0.01) {
				camelWanderTarget.add(new THREE.Vector3(
					Math.random() * camelWanderDistance - camelWanderDistance / 2,
					0,
					Math.random() * camelWanderDistance - camelWanderDistance / 2
				));
			}
		}

		function wander2(tumbleweed) {
			const displacement = new THREE.Vector3();
			displacement.set(Math.random() * 2 - 1, 0, Math.random() * 2 - 1);
			displacement.normalize();
			displacement.multiplyScalar(tumbleweedWanderRadius);

			const wanderForce = new THREE.Vector3();
			wanderForce.addVectors(tumbleweedWanderTarget, displacement);
			wanderForce.sub(tumbleweed.position);
			wanderForce.normalize();
			wanderForce.multiplyScalar(tumbleweedWanderMaxForce);

			tumbleweed.position.add(wanderForce);

			// Update the wander target position periodically to create a wandering effect
			if (Math.random() < 0.01) {
				tumbleweedWanderTarget.add(new THREE.Vector3(
					Math.random() * tumbleweedWanderDistance - tumbleweedWanderDistance / 2,
					0,
					Math.random() * tumbleweedWanderDistance - tumbleweedWanderDistance / 2
				));
			}
		}

		document.addEventListener('keydown', onDocumentKeyDown, false);
		document.addEventListener('keyup', onDocumentKeyUp, false);
		document.addEventListener('mousedown', onDocumentMouseDown, false);
		document.addEventListener('mouseup', onDocumentMouseUp, false);

		function onDocumentKeyDown(event) {
			switch (event.keyCode) {
				case 32: //space
					space = true;
					break;
				case 68: //d
					keyD = true;
					break;
				case 83: //s
					keyS = true;
					break;
				case 65: //a
					keyA = true;
					break;
				case 87: //w
					keyW = true;
					break;
			}
		}
		
		function onDocumentKeyUp(event) {
			switch (event.keyCode) {
				case 32: //space
					space = false;
					break;
				case 68: //d
					keyD = false;
					break;
				case 83: //s
					keyS = false;
					break;
				case 65: //a
					keyA = false;
					break;
				case 87: //w
					keyW = false;
					break;
			}
		}

		function onDocumentMouseDown(event) {
			switch (event.button) {
				case 0: //mouse1
					mouse1 = true;
					break;
				case 1: //mouse_wheel
					mouse_wheel = true;
					break;
				case 2: //mouse2
					mouse2 = true;
					break;
			}
		}

		function onDocumentMouseUp(event) {
			switch (event.button) {
				case 0: //mouse1
					mouse1 = false;
					break;
				case 1: //mouse_wheel
					mouse_wheel = false;
					break;
				case 2: //mouse2
					mouse2 = false;
					break;
			}
		}

		function init() {
			// initialize scene and plane
			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x00001f);

			const stats = new Stats();
			document.body.appendChild(stats.dom);

			// texture
			const textureLoader = new THREE.TextureLoader();
			const texture = textureLoader.load('./textures/sand.jpg');
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.MirroredRepeatWrapping;
			texture.repeat.set(1, 1);
			
			// ground
			const plane = new THREE.PlaneGeometry(20000, 20000, 32);
			const planeMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide });
			planeMaterial.map = texture;
			const planeMesh = new THREE.Mesh(plane, planeMaterial);
			planeMesh.rotation.x = -Math.PI / 2;
			planeMesh.position.set(0, -0.1, 0);
			scene.add(planeMesh);

			// track
			let track = createTrack();
			scene.add(track);

			// power up crates from mario kart
			let _z = 270;
			const powerUps = [];

			const loader = new GLTFLoader();
			loader.load(
				'./assets/power_up/scene.gltf',
				(gltf) => {					
					for (let i = 0; i < 5; i++){
						((index) => {
							const powerUp = gltf.scene.clone();
							powerUp.position.set(0, 0, _z + (index * 15));
							powerUp.scale.set(0.2, 0.2, 0.2);
							scene.add(powerUp);
							powerUps.push(powerUp);
						})(i);
					}
				}
			);

			const placedPositions = []; // Array to store the positions of already placed windmills and cacti
			// windmill
			loader.load(
				'./assets/windmill/scene.gltf',
				(gltf) => {
					
					for (let i = 0; i < 10; i++) {
						((index) => {
							const windmill = gltf.scene.clone();
							let windmill_x, windmill_z;
							let isOverlapping = true;

							// Loop until a non-overlapping position is found
							while (isOverlapping) {
								windmill_x = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 500 + 500); // Random X coordinate between -1000 to -500 and 500 to 1000
								windmill_z = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 500 + 500); // Random Z coordinate between -1000 to -500 and 500 to 1000

								// Check if the new position is overlapping with any previously placed windmills
								isOverlapping = placedPositions.some((position) => {
									const distance = Math.sqrt(
										Math.pow(position.x - windmill_x, 2) +
										Math.pow(position.z - windmill_z, 2)
									);
									return distance < 100; // Adjust the value as per your windmill size
								});
							}

							windmill.position.set(windmill_x, 0, windmill_z);
							windmill.scale.set(4, 4, 4);
							scene.add(windmill);

							// Store the newly placed windmill position
							placedPositions.push({ x: windmill_x, z: windmill_z });
						})(i);
					}
				}
			);


			// cactus
			loader.load(
				'./assets/cactus/scene.gltf',
				(gltf) => {
					const cactus = gltf.scene.clone();
					const placedPositions = []; // Array to store the positions of already placed cacti

					for (let i = 0; i < 50; i++) {
						((index) => {
							let cactus_x, cactus_z;
							let isOverlapping = true;

							// Loop until a non-overlapping position is found
							while (isOverlapping) {
								cactus_x = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 500 + 300); // Random X coordinate between -1000 to -500 and 500 to 1000
								cactus_z = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 500 + 300); // Random Z coordinate between -1000 to -500 and 500 to 1000

								// Check if the new position is overlapping with any previously placed windmills or cacti
								isOverlapping = placedPositions.some((position) => {
									const distance = Math.sqrt(
										Math.pow(position.x - cactus_x, 2) +
										Math.pow(position.z - cactus_z, 2)
									);
									return distance < 100; // Adjust the value as per your cactus size
								});
							}

							const newCactus = cactus.clone();
							newCactus.position.set(cactus_x, 4, cactus_z);
							newCactus.scale.set(0.03, 0.03, 0.03);
							scene.add(newCactus);

							// Store the newly placed cactus position
							placedPositions.push({ x: cactus_x, z: cactus_z });
						})(i);
					}
				}
			);


			// bones
			loader.load(
				'./assets/bones/scene.gltf',
				(gltf) => {
					const bones = gltf.scene.clone();
					bones.position.set(250, 0, -700);
					bones.scale.set(0.1, 0.1, 0.1);
					scene.add(bones);
				}
			);
			
			// entry portal
			loader.load(
				'./assets/portal/scene.gltf',
				(gltf) => {
					for(let i = 0; i < 2; i++){
						(
							(index) => {
								const portal = gltf.scene.clone();
								portal.position.set(0, 0, -550 + (index * 1100));
								portal.scale.set(0.1, 0.1, 0.1);
								portal.rotation.set(0, Math.PI / 2, 0);
								scene.add(portal);
							}
						)(i);
					}
				}
			);

			// camel
			let camel;
			loader.load(
				'./assets/camel/scene.gltf',
				(gltf) => {
					camel = gltf.scene.clone();
					camel.position.set(100, 6, 0);
					camel.scale.set(1.5, 1.5, 1.5);
					scene.add(camel);
				}
			);

			// tumbleweed
			const tumbleweeds = [];
			loader.load(
				'./assets/tumbleweed/scene.gltf',
				(gltf) => {
					for(let i = 0; i < 3; i++) {
						(
							(index) => {
								const tumbleweed = gltf.scene.clone();
								tumbleweed.position.set(100, 0, -100 + (index * 100));
								tumbleweed.scale.set(5, 5, 5);
								scene.add(tumbleweed);
								tumbleweeds.push(tumbleweed);
							}
						)(i);
					}
				}
			);

			// mountain
			loader.load(
				'./assets/mountain/scene.gltf',
				(gltf) => {
					const mountain = gltf.scene.clone();
					mountain.position.set(-1500, -50, 0);
					mountain.scale.set(20, 20, 20);
					mountain.rotation.set(0, Math.PI , 0);
					scene.add(mountain);
				}
			);

			// dune
			loader.load(
				'./assets/dune/scene.gltf',
				(gltf) => {
					const dune = gltf.scene.clone();
					dune.position.set(1750, -10, 0);
					dune.scale.set(15, 15, 15);
					dune.rotation.set(0, -Math.PI / 2, 0);
					scene.add(dune);
				}
			);

			// lightposts
			for(var i = 0; i < 8; i++){
				const angle = Math.PI * 2 / 8 * i;
				var x = Math.sin(angle) * (350 + 200);
				var z = Math.cos(angle) * (350 + 200);
				if(i == 0){
					z -= 150;
				} else if(i == 2){
					x += 150;
				} 
				else if(i == 4){
					z += 150;
				} else if(i == 6){
					x -= 150;
				}
				let lightpost = createLightPost(x, 5, z, i);
				scene.add(lightpost);
			}

			// create a mesh for the car
			let car = createCar();

			// headlights of the car
			const left_light = new THREE.SpotLight(0xffffff, 1.0, 35.0, Math.PI/6, 0.5, 0.15);
			left_light.position.set(car.position.x - 2.5, car.position.y + 1, car.position.z);
			left_light.target.position.set(car.position.x, car.position.y + 1, car.position.z);
			left_light.castShadow = true;
			left_light.shadow.mapSize.width = 1024;
			left_light.shadow.mapSize.height = 1024;
			left_light.visible = true;
			left_light.name = "left_light";
			
			car.add(left_light.target);

			const right_light = new THREE.SpotLight(0xffffff, 1.0, 35.0, Math.PI/6, 0.5, 0.15);
			right_light.position.set(car.position.x + 2.5, car.position.y + 1, car.position.z);
			right_light.target.position.set(car.position.x, car.position.y + 1, car.position.z);
			right_light.castShadow = true;
			right_light.shadow.mapSize.width = 1024;
			right_light.shadow.mapSize.height = 1024;
			right_light.visible = true;
			right_light.name = "right_light";

			car.add(right_light.target);
			
			car.add(left_light);
			car.add(right_light);

			car.position.set(-25,0,-300);
			car.rotation.set(0, -Math.PI / 2, 0);
			scene.add(car);

			function updateLights() {
				const direction = new THREE.Vector3();
				car.getWorldDirection(direction); // Get the direction the car is facing
				//console.log(direction);
				if((direction.z > 0) && (direction.x > 0)){
					left_light.target.position.set(car.position.x + (direction.x*10000), car.position.y, car.position.z - (direction.z*10000));
					right_light.target.position.set(car.position.x + (direction.x*10000), car.position.y, car.position.z - (direction.z*10000));
				}
				else{
					left_light.target.position.set(car.position.x + (direction.x*10000), car.position.y, car.position.z + (direction.z*10000));
					right_light.target.position.set(car.position.x + (direction.x*10000), car.position.y, car.position.z + (direction.z*10000));
				}
				if(direction.x > 0){
					left_light.target.position.set(car.position.x - (direction.x*10000), car.position.y, car.position.z - (direction.z*10000));
					right_light.target.position.set(car.position.x - (direction.x*10000), car.position.y, car.position.z - (direction.z*10000));
				}
			}

			fillScenery(scene);

			// THE LIGHTS
			// ambient light
			ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
			ambientLight.name = "ambient_light";
			scene.add(ambientLight);

			// THE CAMERAS
			// Orthographic camera for top view
			const camera = new THREE.OrthographicCamera(window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000);
			camera.position.set(0, 100, 0);
			camera.lookAt(0, 0, 0);

			// Perspective camera for inside and outside car view
			const camera1 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera1.position.set(0, 10, 20);
			camera1.lookAt(0, 0, 0);

			// driver view
			const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera2.position.set(car.position.x, car.position.y + 2, car.position.z + 5);
			camera2.lookAt(car.position.x, car.position.y, car.position.z);

			var activeCamera = camera;
			scene.add(activeCamera);

			//activeCamera.add( listener );

			// THE RENDERER
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setClearColor(new THREE.Color(0xaaaaaa));
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;

			// Add the output of the renderer
			document.body.appendChild(renderer.domElement);

			// Render the scene
			renderer.render(scene, activeCamera);

			gui(scene);

			animate();
			var step = 0;
			// animate the scene
			function animate() {
				var post_lights = [];
				for(var x = 0; x < 8; x++){
					post_lights[x] = scene.getObjectByName('post_light' + x);
				}
				let left_light = scene.getObjectByName('left_light');
				let right_light = scene.getObjectByName('right_light');
				const trophy = scene.getObjectByName('trophy');
				const arrow = scene.getObjectByName('arrow');
				const flag = scene.getObjectByName('flag');

				// Update car headlights target
				updateLights();

				// rotate the trophy
				trophy.rotation.y += 0.01;

				// rotate the arrow
				arrow.rotation.y = Math.cos(step);

				// rotate the flag
				flag.rotation.x = step * Math.sin(step);
				flag.rotation.y = step * Math.cos(step);
				flag.rotation.z = step * Math.sin(step);

				// move the boxes
				// Update position of each power-up
				powerUps.forEach((powerUp, index) => {
					const yOffset = Math.sin(Date.now() * 0.004 + index) * 2; // Adjust the speed and magnitude as desired
					powerUp.position.setY(yOffset + 2);
					
					if (car.position.distanceTo(powerUp.position) < 5) {
						// Make power-up invisible
						powerUp.visible = false;

						usePowerUp(car);
						carMaterial.color.setHex(0x0000ff);

						// Set a timeout to make the power-up visible again after 10 seconds
						setTimeout(() => {
							powerUp.visible = true;
						}, 10000);
					}
				});

				// animate the camel
				if(camel){
					wander(camel);
					// put the camel on the ground
					camel.position.y = 6;
					camel.rotation.y += 0.001;
				}

				// animate the tumbleweeds
				tumbleweeds.forEach((tumbleweed, index) => {
					if(tumbleweed){
						wander2(tumbleweed);
						// put the tumbleweed on the ground
						tumbleweed.position.y = 0;
						tumbleweed.rotation.set(0.1, 1, 0.1);
					}
				});

				step += 0.01;

				if(step >= 30){
					step = 0.01;
				}

				// Move the car forward or backward
				if (keyW) {
					if(carSpeed < 0){
						carSpeed += carBreaking;
					} else{
						carSpeed += carAcceleration;
					}
					if (carSpeed > carMaxSpeed) {
						carSpeed = carMaxSpeed;
					}
					carAcceleration += 0.0001;
				} else if (keyS) {
					if(carSpeed > 0){
						carSpeed -= carBreaking;
					} else{
						carSpeed -= carReverseAcceleration;
					}
					if (carSpeed < carMaxReverseSpeed) {
						carSpeed = carMaxReverseSpeed;
					}
					carReverseAcceleration += 0.0001;
				}

				// Turn the car
				if(keyA){
					if(carSpeed > 0){
						car.rotation.y += carTurnSpeed;
					} else if(carSpeed < 0){
						car.rotation.y -= carTurnSpeed;
					}
				}
				if(keyD){
					if(carSpeed > 0){
						car.rotation.y -= carTurnSpeed;
					} else if(carSpeed < 0){
						car.rotation.y += carTurnSpeed;
					}
				}

				// Decelerate the car if no key is pressed
				if(!keyW && !keyS){
					if(carSpeed > 0){
						carSpeed -= carDecelerate;
					}
					else if(carSpeed < 0){
						carSpeed += carDecelerate;
					}
					// Reset acceleration and reverse acceleration
					if(carAcceleration > 0.01){
						carAcceleration -= 0.0001;
					}
					if(carReverseAcceleration > 0.01){
						carReverseAcceleration -= 0.0001;
					}
					// Stop the car if it's speed is too low (to prevent it from moving forever)
					if(carSpeed < 0.01 && carSpeed > -0.01){
						carSpeed = 0;
					}
				}

				// Control the sounds
				if(carSpeed == 0){
					engineSound.stop();
				} else if(sound_fx){
					engineSound.play();
				}

				// Make the car move base on it's speed and rotation
				car.position.x -= carSpeed * Math.sin(car.rotation.y);
				car.position.z -= carSpeed * Math.cos(car.rotation.y);

				if(space){
					if(!car_view){
						if(!driver_view){
							activeCamera = camera1;
							driver_view = true;
						}
						else{
							activeCamera = camera2;
							driver_view = false;
							car_view = true;
						}
					}
					else{
						activeCamera = camera;
						car_view = false;
					}
					space = false;
				}

				if(activeCamera === camera1){
					activeCamera.position.copy(car.position);
					if(carSpeed >= 0){
						activeCamera.position.add(new THREE.Vector3(0, 5, 8).applyQuaternion(car.quaternion));
					} else if(carSpeed < 0){
						activeCamera.position.add(new THREE.Vector3(0, 5, -8).applyQuaternion(car.quaternion));
					}
					activeCamera.lookAt(car.position);
				} else if(activeCamera === camera2){
					activeCamera.position.copy(car.position);
					if(carSpeed >= 0){
						activeCamera.position.add(new THREE.Vector3(0, 2, 8).applyQuaternion(car.quaternion));
					} else if(carSpeed < 0){
						activeCamera.position.add(new THREE.Vector3(0, 2, -4).applyQuaternion(car.quaternion));
					}
					activeCamera.lookAt(car.position);
				}

				if(mouse1){
					left_light.visible = !left_light.visible;
					right_light.visible = !right_light.visible;
					mouse1 = false;
				}
				if(mouse2){
					for(var x = 0; x < 8; x++){
						post_lights[x].visible = !post_lights[x].visible;
					}
					mouse2 = false;
				}
				
				requestAnimationFrame(animate);
				renderer.render(scene, activeCamera);
			}
		}

		window.onload = init;
	</script>
</body>
</html>
